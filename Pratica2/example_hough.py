# -*- coding: utf-8 -*-
"""example_hough.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zjXamnOh2rV4ksNd6y4r58z0YiTPnumk

# Examplo da uso da Hough Transform para achar os eixos coordenados em um desenho, e "alinhar" na horizontal
"""

# imports

from google.colab.patches import cv2_imshow
import numpy as np
import time
import cv2

#
#  Rotina para rotacionar uma imagem em torno de um ponto com angulo dado
#

def rotate_image(image, center_point, angle):
  rot_mat = cv2.getRotationMatrix2D(center_point, angle, 1.0)
  result = cv2.warpAffine(image, rot_mat, image.shape[1::-1], flags=cv2.INTER_LINEAR, borderValue = (255, 255, 255))
  return result

#
# Loads example image
#
!wget https://www.inf.ufrgs.br/~crjung/fvc/pratica2/desenho2.jpg
#
#  Carrega a imagem de um plot 2D com eixos coordenados
#
img = cv2.imread('desenho2.jpg')
print('Imagem lida')
cv2_imshow(img)

"""Agora vamos binarizar e pegar o "negativo"""

#
#  Extrai o foreground (grayscale e binarizacao) -- assume que o fundo é mais claro
#

# Converte para tons de cinza
img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Binarizacao usando limiar de Otsu
threshold, bw = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)

# "Negativo" da binarização
bw = 255 - bw
print('Imagem binaria')
cv2_imshow(bw)

"""Veja que temos dois segmentos de reta aproximadamente ortogonais relativos aos eixos cartesianos."""

#
	#  Aplica Hough transform para pegar as linhas
	#
	lines = cv2.HoughLines(bw, 1, np.pi/90, 150)

	#
	# Pega a linha com maior comprimento (espera-se que seja o eixo horizontal)
	#
	line = lines[0]
	rho0 = line[0,0]
	theta0 = line[0,1]

	#
	# Seleciona dentre as demais qual está mais próxima da ortogonalidade
	# com relação à maior (angulo mais proximo de 90 graus) --  o eixo vertical
	#

	error = []
	# varre segunda linha em diante
	for line in lines[1::]:
		rho = line[0,0]
		theta = line[0,1]
		error.append(np.abs( np.abs(theta - theta0) - np.pi/2 ))

	print(error)
	# Pega menor erro
	ind = np.argmin(error)
	line = lines[ind + 1]
	rho1 = line[0,0]
	theta1 = line[0,1]

"""Dadas as equações das duas retas, acha a origem (ponto de intersecção) e rotaciona a image para alinhar o eixo horizontal"""

#
#  Calcula a origem (intersecção)
#
A = np.array([ [np.cos(theta0), np.sin(theta0)], [np.cos(theta1), np.sin(theta1)] ])
B = np.array([ [rho0], [rho1] ])
pt = np.linalg.inv(A)@B
cntr = (int(pt[0,0]), int(pt[1,0]))

#
#  Plota eixos coordenados aproximados
#

# Eixo horizontal
x0 = 0
x1 = img.shape[1]

y0 = int((B[0,0] - A[0,0]*x0)/A[0,1])
y1 = int((B[0,0] - A[0,0]*x1)/A[0,1])
cv2.line(img, (x0,y0), (x1,y1), color = (0,0,255))

# Eixo vertical
x0 = 0
x1 = img.shape[1]

y0 = int((B[1,0] - A[1,0]*x0)/A[1,1])
y1 = int((B[1,0] - A[1,0]*x1)/A[1,1])
cv2.line(img, (x0,y0), (x1,y1), color = (0,0,255))

# mostra imagem original com os eixos estimados sobrepostos
print('Imagem com eixos')
cv2_imshow(img)

#
#  Rotaciona imagem para alinhar eixo horizontal e mostra resultado
#
angle = (theta0 - np.pi/2)*180/np.pi  # angulo do eixo horizontal
img_out = rotate_image(img, cntr, angle)
print('Imagem com eixos alinhados')
cv2_imshow(img_out)